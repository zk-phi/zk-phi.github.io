<!doctypehtml><html lang="ja"><title>zk-phi の部屋 :: 最近の活動</title><meta charset="utf-8"><meta name="viewport"content="initial-scale=1"><meta name="description"content="zk-phi のホームページです"><link rel="preload"href="/fonts/DotGothic16-Regular.woff2"as="font"crossorigin><link rel="stylesheet"href="/css/font.css"><link rel="stylesheet"href="/css/common_critical.css"><link rel="stylesheet"href="/css/activity.css"><script defer src="/js/loader.js"></script><style></style><body id="body"><div id="content"><h1 id="title"><span class="rot">💻</span>最近の活動<span class="rot">💻</span></h1><p><a class="link"href="javascript:history.back()">&lt; 戻る</a><hr><div id="article"class="left"><h2 class="header">コンピュータ言語 / 妄想 - zk_phi PUBLIC scrapbox - Scrapbox</h2><div class="right"><p>Scrapbox (2020/9/6)<a class="link"target="_blank"rel="noreferrer"href="https://scrapbox.io/zkphi/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E8%A8%80%E8%AA%9E_%2F_%E5%A6%84%E6%83%B3">See original</a></div><div id="cdata">名前呼びと値呼びを一つのセマンティクスで表現する<br><span><a href="http://www.cs.bham.ac.uk/~pbl/papers/hosc04.pdf">http://www.cs.bham.ac.uk/~pbl/papers/hosc04.pdf</a></span><span>(PLZooにトイ実装あり)</span><br><br><span>文 (computation 型、</span><span>Prog[int]</span><span>など) と式 (value 型、</span><span>int</span><span>など) を明確に区別して、computation を渡り歩いていくと名前呼び、value を渡り歩いていくと値呼びになるイメージ？</span><br><span>文と式は</span><span>thunk</span><span>+</span><span>force</span><span>/</span><span>return</span><span>で互いに行き来できる (</span><span>return 1</span><span>は</span><span>1</span><span>に評価される computation、</span><span>thunk(X)</span><span>は計算</span><span>X</span><span>を表現する value、</span><span>force(thunk(X))</span><span>で明示的に実行できる)</span><br>モナドですね<br><span>スライドもあった</span><span><a href="https://www.slideshare.net/mobile/ssuser0745d1/call-bypushvalue">https://www.slideshare.net/mobile/ssuser0745d1/call-bypushvalue</a></span><span>けどたぶんやりたいことは</span><span>fexpr</span><span>のが近いな</span><br><br>リストコンテキスト<br><br>「式を評価した結果が多値だった場合、多値オブジェクトが返る。多値オブジェクトがコンスセルの要素に代入されたとき、それはたちどころに展開される」という意味論の多値があればよさそう？<br><span>いや、たとえば</span><span>map</span><span>を</span><span>(if lst (cons (fn (car lst)) (map fn (cdr lst))) nil)</span><span>と定義したとして、</span><span>map (fn (x) @(x x)) lst</span><span>したら</span><span>(cons x x ...)</span><span>になってエラーじゃない？</span><br>やっぱり値に展開される性を持たせるんじゃなく文脈に持たせるところがミソな気がする。 perl。<br>(タイ変数というちょっと真似たくない概念もあった。自分で文脈を追加できるのに近い)<br>逆に、mapをいい感じに定義できることは意味論のベンチマークになりそう<br><br><span>リスト文脈は引数リストにも展開できるのがミソ？</span><span>map</span><span>で使うだけなら</span><span>flatMap</span><span>でよい。</span><span>perl</span><span>はよくできてる</span><br><span>js</span><span>の</span><span>spread</span><span>演算子絶妙なのかもしれない。</span><br><span>(list @(map fn lst))</span><span>で</span><span>flatMap</span><span>、とかがいいとこじゃない？</span><br><span>いや</span><span>(list @(map (fn (x) (list x x)) &#x27;(1 2 3)))</span><span>=</span><span>(list @((1 1) (2 2) (3 3)))</span><span>=</span><span>((1 1) (2 2) (3 3))</span><span>になる、じゃあ</span><span>(1 1 2 2 3 3)</span><span>を作りたい場合は？ spread operator ではやっぱだめ</span><br><span>リスト文脈は spread operator と</span><span>flatMap</span><span>をいっぺんに実現できるところがすごいのか？</span><br><br>話は戻って<br><span>いや、たとえば</span><span>map</span><span>を</span><span>(if lst (cons (fn (car lst)) (map fn (cdr lst))) nil)</span><span>と定義したとして、</span><span>map (fn (x) @(x x)) lst</span><span>したら</span><span>(cons x x ...)</span><span>になってエラーじゃない？</span><br>逆に、mapをいい感じに定義できることは意味論のベンチマークになりそう<br>結局問題は、「どこに展開されるか」が明示できないこと？<br><span>cons</span><span>の時点では展開されなくて良い (じゃあいつ展開されるのが良いんだ？実は</span><span>cons</span><span>の意味論が悪い？)</span><br>どこに展開されるかを指定したい話は、 perl ではリスト文脈 (リストを受け取りますよー) の明示、 lisp の多値では values を受け取りますよのシンタックスがあることで解決している<br>lisp では逆に全てがリストなのがネック？スペシャルフォームと関数の引数リストとの区別が必要？<br><span>(progn (map (fn (x) @(x x)) &#x27;(1 2)))</span><span>の結果はたぶん</span><span>2</span><span>ではなく</span><span>(1 1 2 2)</span><span>が期待される</span><br>同じようなことは関数 - 関数間でも起こるのか？ここではまだ展開して欲しくない、というケース<br>perl はスペシャルフォームに展開はできない。関数はなんか別に良いんじゃないか perl でもできないでしょ<br>スペシャルフォームだけ特別扱いするのがキモいかどうかの問題？本当か？<br>perl が本質的にみんなリストを受け取る１引数関数になってるのもよくできてるよなあ<br><br>マクロの行く先<br><br>kinaba さんのようにレイヤの概念に一般化するか、逆に fexpr とかでファーストクラスにもってくるかがしっくりきそう<br><span>fexpr を現役で？採用する Kernel 言語</span><span><a href="https://web.cs.wpi.edu/~jshutt/kernel.html">https://web.cs.wpi.edu/~jshutt/kernel.html</a></span><br><span>Kernel の人の D 論もあった</span><span><a href="https://t.co/BfCydJ3TuL">https://t.co/BfCydJ3TuL</a></span><span>lambda calculus に対応する vau calculus で、マクロまで込みの定式化とかがある 興味関心の世界</span><br><br>継続の皮むき<br><br><span>継続オブジェクトを、スタックトップの部分継続と残りの継続に分解するオペレータがあると、 kinaba さんの真自然言語プログラミングみたいなことができる</span><span><a href="http://www.kmonos.net/pub/Presen/fltv/FLTV.pdf">http://www.kmonos.net/pub/Presen/fltv/FLTV.pdf</a></span><br>ある式が評価される中で、親の式の意味が変わる<br><br>継続の定数オーダー補足<br><br>継続を使った effect っぽい例外処理を基本にするなら、継続の補足をなるべく定数にしたい感じがする<br>変数に保存してなんども使うとかしない限り実りリエントラントである必要はなくて、その範囲ならコピーもいらない感じはする<br><span>segmented stack というのでできるらしい</span><span><a href="https://www.cs.indiana.edu/~dyb/pubs/stack.pdf">https://www.cs.indiana.edu/~dyb/pubs/stack.pdf</a></span><br></div></div><hr><p><a class="link"href="javascript:history.back()">&lt; 戻る</a></div><script>const lazyScripts=["/js/prefetch.js","/js/stalker.js","/js/activity.js"],lazyStyles=["/css/common.css","/css/stalker.css"]</script>