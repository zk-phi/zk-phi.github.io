<!doctypehtml><html lang="ja"><title>zk-phi の部屋 :: 最近の活動</title><meta charset="utf-8"><meta name="viewport"content="initial-scale=1"><meta name="description"content="zk-phi のホームページです"><link rel="preload"href="/fonts/DotGothic16-Regular.woff"as="font"crossorigin><link rel="stylesheet"href="/css/font.css"><link rel="stylesheet"href="/css/common_critical.css"><link rel="stylesheet"href="/css/activity.css"><script defer src="/js/loader.js"></script><script defer src="/js/bg.js"></script><style></style><body id="body"><canvas id="bg"></canvas><div id="content"><h1 id="title"><span class="rot">💻</span>最近の活動<span class="rot">💻</span></h1><p><a class="link"href="javascript:history.back()">&lt; 戻る</a><hr><div id="article"class="left"><h2>身の回りの振動デバイスを一括制御して””シナスタジア””を得る</h2><div class="right"><p>Qiita (2021/11/9)<a class="link"target="_blank"rel="noreferrer"href="https://qiita.com/zk_phi/items/888da61363e73d90c7c5">See original</a></div><div id="cdata"><h1>なにをやったの</h1><p>身の回りの振動デバイス (ゲームのコントローラーなど) を PC から一括制御して、手軽に””シナスタジア””を得られないか試してみました。<p>おまけで映画などのコンテンツに振動を連動させる実験もしてみました。<p>手持ちの Joy-Con などで手軽に試せるので、よかったら遊んでみてください。<p>実装的には、ブラウザから周辺機器に直接コマンドを送る WebUSB, WebHID などの実験的な技術を使ってみたので、そのあたりの話もします。<h1>シナスタジア？？</h1><p>「シナスタジア」は「共感覚」という意味の英単語ですが、ここでは「スペースチャンネル５」などでお馴染みのゲームプロデューサー (アーティスト？)<a href="https://ja.wikipedia.org/wiki/%E6%B0%B4%E5%8F%A3%E5%93%B2%E4%B9%9F">水口氏</a>の提唱する「シナスタジア」を指します。<p>氏はプレーヤーの操作、光の演出、音楽、振動などが絶妙にシンクロすることで得られる独特のキモチ良さ、トリップ感 (意訳) をコンセプトにしたゲームを多く作っていて、この体験を「シナスタジア」と呼んでいます。<p>&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/F4YfF3nvxDE&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;<p>音・映像の美しさももちろん大事なのですが、振動を通して「体で感じる」ことも「シナスタジア」の重要な要素です。実際、「シナスタジア」シリーズ初のゲームである「Rez」には、「BGM に合わせて振動するだけ」の超攻めた周辺機器「トランスバイブレータ」が付属していました。一作目でこれはなかなか挑戦的ですよね。<p>&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/Sa_1BgjUjjo&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;<p>その後も「音を全身で感じる」体験の研究は続き、２６個の振動デバイスを内蔵した着る体感デバイス「シナスタジアスーツ」などが開発されました。販売はありませんが、<a href="https://enhance-experience.com/ja/3147">アートイベント</a>などで体験できることがあります (もちろん行きました)。<p>https://synesthesia-suit.com/<p>当時はキワモノ扱いだった印象もありますが、 (<a href="https://twitter.com/ahtoh2011/status/1425624731659636739?s=20">Amazon にアダルトグッズ扱いされる憂き目</a>に遭ったりしながらも) しっかりコアなファンがついているコンテンツでした。その後、 15 年の時を超えて VR に、ほとんどそのままの内容で移植された「Rez」がバッチリ高評価を獲得したり、「着る振動デバイス」を<a href="https://www.bhaptics.com/">VR 向けに販売するメーカー</a>が現れたりして、いよいよ時代が追いついてきた感があります。<p>(実際、氏は<a href="https://www.j-platpat.inpit.go.jp/c1800/PU/JP-H10-080575/8FF11F2C97899A2A157807801EF8E0407144E82DDA561EAF9C729B95C0B0BB20/11/ja">30 年前の時点でゴーグルをかぶって遊ぶゲーム機の特許を出願</a>していますし、本当に未来を見ていたんだと思います。<s>いかにもセガっぽいです</s>)<p>最近では往年の名作「テトリス」に「シナスタジア」を取り入れた作品「テトリスエフェクト」が発売されて話題になったりもしました。えっこれがテトリス？？ってなるくらいめっちゃ綺麗なので観てください👇<p>&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/urbLIyd-VsQ&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;<p>さて、今回はこの「音・映像・振動が融合するキモチ良さ」をもっと手軽に味わえると楽しいのになーと思って、身の回りの振動デバイスを PC から一括制御する実験をしてみたので紹介します。ぜひ音楽を耳だけじゃなく、全身で浴びる体験をしてみてほしいです。<h3>ちなみに</h3><p>今年は「Rez」の 20 周年、<a href="https://oengus.io/marathon/rtaijw2021">RTA in Japan の種目に選ばれ</a>たり、<a href="https://www.moguravr.com/2020-2021-vr-ar-mr/">続編の匂わせ</a>もあったりするので、もし興味を持ったらこれを機にぜひ触れてみてください！<h1>ここで遊べます</h1><p>※ 最新の Chrome が必要です<p>https://zk-phi.github.io/trance-vibrator-resuscitator/<p>「Rez」の PV に合わせて、ブラウザから Joy-Con などの各種ゲームコントローラーや、例の「トランスバイブレータ」を制御できるアプリです。<p>(おまけで映画や他の音楽・ゲーム音などに連動させる仕組みも作ってみました。よかったらそっちも試してみてください、楽しいです)<p>一応無保証なのでご注意ください。<p>デバイス数に上限はないので、ケツにトランスバイブレータを敷いて、腰に DualSense を当てて、両手に Joy-Con を握りしめて、一緒にアチラ側に行きましょう。うっかり同居人に見られるととても恥ずかしいので気をつけてください。<p>他に連動させると面白そうなデバイスを思いついた人がいたら、ぜひ PR ください！<h3>デバイスの繋ぎ方</h3><p>トランスバイブレーターは USB で、 Joy-Con / Pro-Con は Bluetooth で PC に接続できます。繋いだらアプリの<code>+ CONNECT</code>ボタンで登録してください。<p>Joy-Con は PC につなぐとホームボタンが光ってびっくりしますが、ペアリングボタンを１回押すと戻ります。<p>Windows の場合、そのままだとトランスバイブレータが「不明なデバイス」になってしまって使えないので、汎用の USB ドライバを入れてやる必要があるっぽいです (未検証)。<p>参考👇<p>https://qiita.com/frameair/items/abcaebbd654c304a0906<h3>それ以外のコントローラーの繋ぎ方</h3><p>「アプリを開いた状態で」コントローラーを繋いで、<code>+ CONNECT</code>ボタンで登録してください。認識しない場合は「アプリを開いた状態で」適当にボタンをポチポチしてからもう一度<code>+ CONNECT</code>してみるとうまくいくことがあります。<h3>映画や他の音楽、ゲームに連動させる</h3><p><code>capture other audio devices / desktop audio</code>を押すと遊べます。<p>PC に接続されているデバイス (キャプボ、マイクなど) に連動するか、 Chrome の他のタブで開いている動画 (など) に連動するか選べます。<p>ゲームなどの音を取り込みたい場合はステミキ、仮想オーディオデバイスなどが要るかもです。<h1>技術的な話</h1><p>ここからは技術的な話です。<h2>WebHID / Joy-Con, Pro-Con を制御する</h2><p>HID はキーボード、マウス、ジョイスティックなど、人間がコンピューターとやりとりするためのデバイスの総称です。 WebHID はブラウザから HID デバイスを直接制御できる技術です。<p>ゲームコントローラーも HID デバイスの一種なので、 WebHID から制御できます。<h3>HID デバイスに接続する</h3><p>ブラウザが WebHID に対応している場合、<code>navigator.hid.requestDevice</code>でデバイスを取得できます。デバイスを取得したら、<code>.open</code>で接続できます。<pre><code class="language-js">const joyCons = await navigator.hid.requestDevice({
  filters: [
    { vendorId: 0x057e },
  ],
});
joyCons[0].open();
</code></pre><p><code>vendorId</code>はデバイスのメーカーを表す ID で、任天堂は<code>0x057e</code>として登録されています。<p><code>filters</code>で<code>vendorId</code>を指定してあげることで、関係ないデバイスに繋いでしまうことを避けられます。<h3>HID デバイスにコマンドを送る</h3><p>HID デバイスには<code>.sendReport</code>でコマンドを送ることができます。<pre><code class="language-js">joyCons[0].sendReport(reportId, Uint8Array.from(args));
</code></pre><p>デバイスがどんなコマンドに対応しているかは各自調べる必要があります。 Switch 関連の解析情報はここにまとまっています。<p>https://github.com/dekuNukem/Nintendo_Switch_Reverse_Engineering<p>HD 振動を制御するコマンドのパケットは作り方がちょっとややこしいので、上のページや、アプリのソースコードを見てみてください。<h2>GamePad API / それ以外のゲームパッドを制御する</h2><p>GamePad API はブラウザでゲームパッドを使うための API です。実は Joy-Con / Pro-Con も GamePad API から使うことができますが、 HD 振動の細かい制御ができないのであちらは WebHID で自前実装しました。<p>Joy-Con 以外の現代のパッドは手元になくて動作確認できないので、 GamePad API でまとめて対応しました。 PS5 の Dualsense なんかがちゃんと動くっぽいです。<h3>パッドに接続する</h3><p>ブラウザが GamePad API に対応していれば、<code>navigator.getGamepads</code>でゲームパッドを取得できます。<pre><code class="language-js">const pads = navigator.getGamepads();
</code></pre><p>(おそらくセキュリティ上の理由で) 「ページを開いた状態で」接続されたパッドしか取得できないようです。もとからパッドが刺さっていて、後からページを開いた場合は認識されません。<h3>パッドの振動を制御する</h3><p><code>getGamepads</code>で取得したゲームパッドには、そのまますぐにコマンドを送れます。<pre><code class="language-js">pads[0].vibrationActuator.playEffect(&quot;dual-rumble&quot;, {
  duration: 1000,
  weakMagnitude: value1,
  strongMagnitude: value2,
});
</code></pre><p><code>.vibrationActuator</code>がない場合は振動に対応していないっぽいです。たいていのコントローラーは振動モーターが２つ入っていますが、それぞれの出力を独立して設定できます。値は<code>0~1</code>です。<h2>WebUSB / トランスバイブレーターを制御する</h2><p>WebUSB は HID ですらない謎 USB デバイスをブラウザから直接制御できる技術です。<h3>USB デバイスに接続する</h3><p>接続方法はだいたい WebHID と同じです。<pre><code class="language-js">const vib = await navigator.usb.requestDevice({
  filters: [
    { vendorId: 0x0b49, productId: 0x064f },
  ],
});
vib.open();
</code></pre><h3>USB デバイスにコマンドを送る</h3><p>デバイスがどんなコマンドに対応しているかはやはりデバイスごとに調べる必要があります。<p>トランスバイブレータの場合は、コントロールコマンドで<code>0~255</code>の値を送ることで振動の強さがセットできるようです。<pre><code class="language-js">await vib.selectConfiguration(1);
await vib.claimInterface(0);
vib.controlTransferOut({
  requestType: &quot;vendor&quot;,
  recipient: &quot;interface&quot;,
  request: 1,
  value: value,
  index: 0,
});
</code></pre><h1>YouTube 動画に連動させる</h1><h3>方針</h3><p>YouTube の js API を調べてみると、現在の再生位置 (秒) が<code>getCurrentTime</code>で取れると書いてあります。<p>https://developers.google.com/youtube/iframe_api_reference<p>「再生位置を受け取って、振動の強さを返す関数<code>getVibValue</code>」を実装すれば、こんな感じで連動できそうです：<pre><code class="language-js">const syncVib = () =&gt; {
  const time = youtubePlayer.getCurrentTime();
  const vibValue = getVibValue(time);
  vibrator.sendVib(vibValue);
}

// syncVib を定期的に呼び出す
setInterval(syncVib, 30);
</code></pre><p>「いっせーのせ」で動画と振動タイマーを同時にスタートする方法もあるかなと思いましたが、だんだんズレちゃったり、あるいはシークバーに対応できなかったりしそうなのでやめました。持たなくて良い状態は持たない方がいいですね。<h3>再生位置を受け取って、振動の強さを返す関数</h3><p>は、こんな感じで実装しました。<pre><code class="language-js">const withBPM = (bpm, array) =&gt; time =&gt; array[Math.floor(time * bpm * 4 / 60)] || 0;

// テンポ 140 の曲のパターン
const pattern = withBPM(140, [
  // 1                    2                       3                       4
  1.00, 0.00, 0.00, 0.00, 1.00, 0.00, 0.00, 0.00, 1.00, 0.00, 0.00, 0.00, 1.00, 0.00, 0.00, 0.00, 
  ...
]);
</code></pre><p>曲のテンポ (BPM) は「１分間に何拍あるか」なので、<code>Math.floor(time * (bpm / 60))</code>で「今何拍目か」が得られます。あとは「１拍目なら振動は<code>1.00</code>、２拍目なら<code>0.50</code>、…」みたいな配列を用意して、そこから目当ての拍に対応する値を取り出せば OK です。<p>実際には 16 分音符まで対応したかったので、４倍して<code>Math.floor(time * bpm * 4 / 60)</code>としました。<p>テンポの違う複数の曲が入っている場合はこんな感じで対応できます：<pre><code class="language-js">const song1 = withBPM(120, [ ... ]);
const song2 = withBPM(160, [ ... ]);

// ２曲目 (song2) が 0:20 から始まる場合
const pattern = time =&gt; song1(time) + song2(time - 20);
</code></pre><h1>WebAudio / その他の音楽、映画などに連動させる</h1><p>WebAudio はブラウザで高度な音声処理を簡単にできる技術です。<p>YouTube 動画との連動では手でパターンを打ち込みましたが、それ以外の音源に連動させる場合はそうはいきません。<p>そこで音声処理を使って、音声からいい感じの振動パターンを生成します。<h3>他のタブの音をキャプチャする</h3><p>他のタブから音をキャプチャするためには、<code>navigator.mediaDevices.getDisplayMedia</code>を使用します。<pre><code>const stream = navigator.mediaDevices.getDisplayMedia();
</code></pre><h3>デバイス (マイク、キャプボなど) の音をキャプチャする</h3><p>それ以外のデバイスから音をキャプチャしたい場合、まずはユーザーにマイク使用を許可してもらう必要があります。<pre><code class="language-js">const mic = await navigator.mediaDevices.getUserMedia({ audio: true });
</code></pre><p><code>getUserMedia</code>は Web カメラなども取得してしまうため、音声デバイスに絞るために<code>{ audio: true }</code>を指定します。<p>マイクから音をキャプチャする場合は、<code>getUserMedia</code>の戻り値をそのまま使用できます。が、それ以外のデバイス (キャプボなど) にも対応したい場合、あらためて接続するデバイスを選ぶ必要があります。<p>使用可能なデバイスの一覧は<code>navigator.mediaDevices.enumerateDevices</code>で得られます。マイクの使用許可をもらう前にこのメソッドを叩いても、正しい情報が得られません (おそらくセキュリティ上の理由)。<pre><code class="language-js">const devices = await navigator.mediaDevices.enumerateDevices();
// 音声入力デバイスに絞る
const audioDevices = devices.filter(dev =&gt; dev.kind === &quot;audioinput&quot;);
</code></pre><p>接続したいデバイスが決まったら、あらためて<code>getUserMedia</code>で接続します。<pre><code class="language-js">const stream = await navigator.mediaDevices.getUserMedia({
  audio: { deviceId: audioDevices[i].deviceId },
});
</code></pre><p><code>deviceId</code>を指定することで、特定のデバイスに狙い撃ちで接続できます。<h3>キャプチャした音をゴニョゴニョする</h3><p>音を取り込む準備ができたら、いよいよ WebAudio らしい処理を書いていきます。<p>WebAudio は「ノード」と呼ばれる部品を回路のように繋いでいくことで音声信号を処理します。<p>まずは取り込んだ音を再生するノードを用意します。<pre><code class="language-js">const ctx = new AudioContext();
const source = source = new MediaStreamAudioSourceNode(ctx, {
  mediaStream: stream,
});
</code></pre><p><code>stream</code>は上の節でキャプチャした音声です。<p>低音に合わせて振動してくれるとキモチ良さそうなので、低域だけを取り出すフィルタノードを作ります。<pre><code class="language-js">const lpf = new BiquadFilterNode(ctx, {
  type: &quot;lowpass&quot;,
  Q: 1,
  frequency: 90,
});
</code></pre><p>このフィルタは 90 Hz より高い音をカットします。これくらいガッツリカットすると、もはや人の声などはほとんど入らなくなり、バスドラムや地鳴りなどのズーンと低い音だけが取り出せます。<code>Q</code>はフィルタの Q 値です、詳しくはフィルタの勉強をしてください。<p>フィルタした音から振動パターンを生成したいのですが、「振動パターン生成ノード」はさすがに組み込まれていないので、自前実装する必要があります。そのためにフィルタした音の生データがほしいので、解析ノード (<code>AnalyserNode</code>) を作ります。<pre><code class="language-js">const analyzer = new AnalyserNode(ctx, {
  fftSize: 1024,
});
</code></pre><p><code>fftSize</code>は FFT (高速フーリエ変換) のウィンドウサイズです。解析に使うデータのサンプル数みたいな感じだと思ってください。<p>最後に処理された音の流れ着く先 (？) を作ります。これがないと音が流れ始めません。<pre><code class="language-js">const dest = new MediaStreamAudioDestinationNode(ctx);
</code></pre><p>必要なノードが揃ったら、これらを接続してやれば音が (ノードの中を) 流れ始めます。<pre><code class="language-js">source.connect(lpf).connect(analyzer).connect(dest);
</code></pre><p><code>AnalyzerNode</code>を流れる音は、外から取り出すことができます。<pre><code class="language-js">// fftSize と同じ大きさの配列
const buf = new Float32Array(1024);
analyzer.getFloatTimeDomainData(buf);
</code></pre><p>音がでかいほど振動を強くするのが順当だと思うので、振動の強さを計算する関数はこんな感じになりそうです。<pre><code class="language-js">const GAIN = 3.5;
const buf = new Float32Array(1024);
const vibValueFromSound () {
  analyzer.getFloatTimeDomainData(buf);
  const max = Math.max(...buf);
  const min = Math.min(...buf);
  return (max - min) * 0.5;
}
</code></pre><p>音声信号から一番値のでかいところ<code>max</code>と、ちいさいところ<code>min</code>を計算して、その差を返します。<p>音声信号は<code>-1 ~ 1</code>の波なので、<code>max - min</code>は最大で<code>2</code>になります。これに<code>0.5</code>を掛けることで、<code>0 ~ 1</code>の範囲に収めます。<p>感度が悪い場合は適宜定数倍して調整するといいと思います。<pre><code class="language-diff">-  return (max - min) * 0.5;
+  return Math.min(1, (max - min) * 0.5 * GAIN);
</code></pre><p><code>1</code>を超えてしまわないように<code>Math.min(1, ...)</code>しておく必要があることに注意してください。<p>これを定期的に呼び出してあげれば音と振動を同期できます。<pre><code class="language-js">setInterval(() =&gt; {
  const vibValue = vibValueFromSound();
  sendVib(vibValue);
}, 30);
</code></pre><h2>おまけ： WebGL でオーディオビジュアライザを書く</h2><p>見た目もかっこいい方がいいので、 WebGL でオーディオビジュアライザを書きました。<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/54240/4fc490e1-1a27-d0ae-438e-ee116906cd5d.png"alt="スクリーンショット 2021-11-09 23.38.34.png"><p>(余力があれば後日詳細書きます)<h1>まとめ</h1><p>いろいろ新しめなブラウザ技術を試しつつ、音と振動を同期させてみました。<p>ぜひぜひ遊んでみてください！</div></div><hr><p><a class="link"href="javascript:history.back()">&lt; 戻る</a></div><script>const lazyScripts=["/js/prefetch.js","/js/stalker.js","/js/activity.js"],lazyStyles=["/css/common.css","/css/stalker.css"]</script>