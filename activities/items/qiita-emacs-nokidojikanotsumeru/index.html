<!doctypehtml><html lang="ja"><title>zk-phi の部屋 :: 最近の活動</title><meta charset="utf-8"><meta name="viewport"content="initial-scale=1"><meta name="description"content="zk-phi のホームページです"><link rel="preload"href="/fonts/DotGothic16-Regular.woff"as="font"crossorigin><link rel="stylesheet"href="/css/font.css"><link rel="stylesheet"href="/css/common_critical.css"><link rel="stylesheet"href="/css/activity.css"><script defer src="/js/loader.js"></script><script defer src="/js/bg.js"></script><style></style><body id="body"><canvas id="bg"></canvas><div id="content"><h1 id="title"><span class="rot">💻</span>最近の活動<span class="rot">💻</span></h1><p><a class="link"href="javascript:history.back()">&lt; 戻る</a><hr><div id="article"class="left"><h2>Emacs の起動時間を&quot;&quot;詰める&quot;&quot;</h2><div class="right"><p>Qiita (2020/9/4)<a class="link"target="_blank"rel="noreferrer"href="https://qiita.com/zk_phi/items/33514d247d8c24338046">See original</a></div><div id="cdata"><p>おしらせ ： 長い記事は本形式になっていた方が読みやすそうなので、 Zenn に<a href="https://zenn.dev/zk_phi/books/cba129aacd4c1418ade4">お引越し</a>してみました。ここにも記事は残しておきますが、最新版はあちらになります。<hr><p>Emacs はプラグインを増やしていくと起動に何秒もかかって重い、という話をみることがあります。<p>しかし、考えてみれば Emacs には 1000 以上の Emacs Lisp ファイルが初めから同梱されているわけで、そこに数十のプラグインを足しただけで爆裂に遅くなるのは、なにか設定にも問題がある気がします。<p>この記事では、 Emacs の起動時間を詰めるために今までに試してきた、小技や大技たちを紹介します。<p>自分用にメンテしているフレームワーク<a href="https://github.com/zk-phi/setup">setup.el</a>で活用しているテクニックが主なので、そちらを試してみて欲しい気持ちもありますが、それぞれの Tips 単体でも価値があると思うので記事にもまとめてみることにしました。<hr><p>参考までに、私の設定ファイルは<a href="https://github.com/zk-phi/dotfiles">こちら</a>にあります。<code>init.el</code>本体だけで 4500 行くらい (＋別ファイルで定義されたコマンドたち) ありますが、初期設定にかかる時間 (<code>init.el</code>の読み込みが始まってから<code>after-init-hook</code>を呼び終わるまでの時間) は 0.04 秒程度だったので、ほぼ素の Emacs と変わらない起動時間と言っていいと思います。<h2>テクニック紹介の前に</h2><h3>emacsclient について</h3><p>Emacs を起動しっぱなしにして、そもそも何度も起動しないようにするという手法 (emacsclient) もあります。<p>起動自体を速くすることとは別路線の手法になるので、この記事ではスコープ外としますが、試してみる価値はあると思います。<h3>init.el のプロファイリングについて</h3><p>チューニングを行う際は、何がボトルネックになっているのかを調べるのが大事です。<p><code>init.el</code>の先頭に<pre><code class="language-emacs-lisp">(require 'profiler)
(profiler-start 'cpu)
</code></pre><p>末尾に<pre><code class="language-emacs-lisp">(profiler-report)
(profiler-stop)
</code></pre><p>などと書いておくことで、<code>init.el</code>のプロファイルを取ることができます。<p>処理に時間のかかっている関数を簡単に見つけることができるので、より効率の良い関数で代用する、コンパイル時に処理してしまってキャッシュする、あるいはその重い関数を使用しているパッケージ自体のロードを遅延するなど、作戦を考えやすいです。<p>より効果の大きそうなところからチューニングしていくとやる気が出ます。<p>では、いよいよ本題に入っていきます。<h2>バイトコンパイル</h2><p>全人類がやるべき設定その１です。<p><code>init.el</code>や各種パッケージのソースコードを、 Emacs が処理しやすい形 (<code>.elc</code>) にあらかじめ変換しておきます。<p><code>M-x byte-compile-file</code>でコンパイルできるので、片っ端からコンパイルしましょう。コンパイルされたファイルがあれば Emacs が勝手にそちらを優先してロードします。<p>dired を扱える方は、<code>dired-do-byte-compile</code>という一括コンパイルコマンドがあるので、手動で入れているパッケージがたくさんある場合は便利です。<p>ソースコードを編集した時は再度バイトコンパイルするのを忘れないようにしましょう (自動化も手だと思います)。<h2>autoload と with-eval-after-load</h2><p>全人類がやるべき設定その２です。<h3>正統派な使い方</h3><p>たとえば Perl 言語の設定は Perl のファイルを開くまで必要ないですし、Web ブラウザ eww の設定は eww を起動するまで必要ありません。それらを一度も使うことなく Emacs を閉じることがあれば、設定にかかった時間はまるまる無駄になってしまいます。<p>これを防ぐのが<code>autoload</code>と<code>with-eval-after-load</code>です。<p>例を挙げます：<pre><code class="language-emacs-lisp">;; hoge パッケージを読み込む
(require 'hoge)

;; hoge パッケージの初期設定をする
(hoge-initialize)

;; hoge パッケージのコマンドにキーを割り当てる
(global-set-key (kbd &quot;C-x h&quot;) 'hoge-run)
</code></pre><p>このようなコード片は、たいていの場合、次のように書き換えることができます。<pre><code class="language-emacs-lisp">;; hoge-run コマンドが実行されそうになったら慌てて hoge パッケージを読み込む
(autoload 'hoge-run &quot;hoge&quot;)

;; hoge パッケージが読み込まれたらすぐに初期設定をする
(with-eval-after-load 'hoge
  (hoge-initialize))

(global-set-key (kbd &quot;C-x h&quot;) 'hoge-run)
</code></pre><p>書き換え後のコード片は、キーバインドの設定だけを起動時に行い、パッケージの読み込みは<code>hoge-run</code>コマンドが実行されるまで遅延します。パッケージが読み込まれると、<code>with-eval-after-load</code>が<code>hoge-run</code>の処理に移る前に割り込んで初期設定を実行するので、ほとんどの場合これで問題ありません。<p>この書き換えによって、<code>hoge-run</code>コマンドがそもそも使われなければ<code>hoge</code>パッケージの設定はそもそも行われないし、仮に使うとしても起動時にすべてのパッケージの設定を行うよりはずっと起動時間が短くなります。<p>特定の言語だけで使用するパッケージなども同様に、トリガーだけを設定しておいて読み込みを遅延することができます。<pre><code class="language-emacs-lisp">(autoload 'sugoi-python-minor-mode &quot;sugoi-python&quot;)
(add-hook 'python-mode-hook 'sugoi-python-minor-mode)
</code></pre><p>「起動時に必要とは限らないな」というパッケージに片っ端からこれを適用しましょう。突き詰めると、フォントやカラースキームの設定、ごく基本的なパッケージの読み込み（「かっこを光らせる」など）くらいしか、起動時に必須な設定はないことに気づくと思います。となれば当然、起動はかなり速くなります。<hr><p>ところで自分はずっと<code>with-eval-after-load</code>(<code>eval-after-load</code>) の第一引数をファイル名の文字列にして使っていたのですが、<pre><code class="language-emacs-lisp">(with-eval-after-load &quot;hoge&quot;
  '(hoge-initialize))
</code></pre><p>シンボル (<code>'hoge</code>) にしておいた方がわずかに速いことに最近気づきました。前者はパッケージが読み込まれたかのチェックに正規表現を使うのに対して、後者はたんに<code>eq</code>で比較されるためです。オーダーは変わらないですが定数倍が良いです。<h3>autoload を使った小技</h3><p>ある自分で実装した関数があって、これがあるパッケージ<code>foo</code>を利用している場合、次のように書くことで軽率に遅延することができます。<pre><code class="language-emacs-lisp">(autoload 'my-special-foo-command &quot;foo&quot;)

(with-eval-after-load 'foo
  (defun my-special-foo-command ()
    ...))
</code></pre><p>こう書いても微々たる差かもですが…。<pre><code class="language-emacs-lisp">(defun my-special-foo-command ()
  (require 'foo)
  ...)
</code></pre><p>まとまった数の自作コマンドがある場合は、それらをまとめて別ファイルに移動してしまい、まるっと<code>autoload</code>するのも手です。<h2>タイマーを使った擬似非同期</h2><p>起動時に必要なパッケージ以外を片っ端から<code>autoload</code>してもまだ起動に時間がかかる (起動時に必要なパッケージだけでもそれなりにある) 場合は、それらを「少しずつ」セットアップしていくと快適です。<p>すなわち、全てのセットアップが完了してから初めてユーザーの入力を受け付けるのではなく、ユーザーの入力も受けつつ裏で並行してセットアップを進めることで、体感の起動速度＝待たされ感が改善します。<p>最近入ったスレッド機能を使うことも考えられますが、まだ不安定そうな雰囲気もあるので、私はタイマーを使っています。スレッドを使っても現状は結局ノンプリエンプティブなので、ユーザーの入力を少しずつブロックしながらやっていくことには変わりなくて、タイマーに対してさほど優位点がないように思います。<p>タイマーを使う場合は、以下のように<code>after-init-hook</code>あたりでタイマーをスタートさせて、各設定項目を細切れに処理してゆけば ok です。<pre><code class="language-emacs-lisp">;; 非同期に行う設定のリスト
(defvar my-delayed-configurations nil)

;; 0.1 秒ずつ間隔を開けながら消化
(defvar my-delayed-configuration-timer nil)
(add-hook 'after-init-hook
          (lambda ()
            (setq my-delayed-configuration-timer
                  (run-with-timer
                    0.1 0.1 ; 0.1 秒ごとに
                    (lambda ()
                      (if my-delayed-configurations ; まだやることがあれば
                          (eval (pop my-delayed-configurations)) ; 一個やる
                        (cancel-timer my-delayed-configuration-timer)))))))
</code></pre><p>タイマーで少しずつ間隔を開けながら処理することで、ユーザーからの入力を (Emacs が) 処理する余地が生まれるので、体感の待たされ感が軽減します。<p>「非同期に実行する設定のリスト」に要素を追加するためのマクロを用意しておくと便利です。<pre><code class="language-emacs-lisp">(defmacro with-delayed-execution (&amp;rest body)
  (declare (indent 0))
  `(push ',(cons 'progn body) my-delayed-configurations))

(with-delayed-execution
  (require 'foo)
  (foo-mode 1))
</code></pre><h2>便利ライブラリへの依存を見直す</h2><p>Emacs Lisp には<code>cl-lib</code>をはじめ、便利関数をまとめたライブラリが色々あります。これらを使うことで設定ファイルをスマートに書くことができますが、ロードはもちろん無料ではありません。<p>これらの便利ライブラリを使うとき、「使うのはマクロだけにとどめる」ことを意識すると起動の高速化になります。たとえば<code>cl-lib</code>で定義されている<code>cl-case</code>は関数ではなくマクロですが、一方<code>cl-every</code>は関数です。マクロはコンパイルの時にマクロを使わない形の式に展開されるので、一度コンパイルしてしまえば、起動時にそのマクロが定義されている必要はありません。<p>依存をマクロだけにすることができると、<pre><code class="language-emacs-lisp">(require 'cl-lib)
</code></pre><p>を以下のように書き換えて、<pre><code class="language-emacs-lisp">(eval-when-compile
  (require 'cl-lib))
</code></pre><p>ロードをコンパイル時に限ることができます。これによって便利マクロたちを実質無料で使用することができ、起動は当然速くなります。<p>あるシンボルが関数なのかマクロなのか調べたい場合は、<code>M-x describe-function</code>が便利です。<hr><p>注：「起動時にロードしたいパッケージ」の中に<code>cl-lib</code>(など) の関数に依存しているものがあれば、せっかく頑張って<code>init.el</code>から依存を消したところで結局<code>cl-lib</code>はロードされてしまいます。<p>パッケージがロードされているかどうかは<code>featurep</code>関数で調べることができます。たとえばもし Emacs 起動直後に<code>(featurep 'cl-lib)</code>が<code>t</code>を返すようであれば、何か別のパッケージが間接的にロードしてしまっています。<p>そのようなパッケージは上の擬似非同期ロードのテクニックで遅延してしまうのがおすすめです。<h2>チューニングの効果を検証する</h2><p>パッケージの読み込みタイミングに関するチューニング（遅延・非同期ロード、便利パッケージ依存脱却）を行う際、「本当にロードを遅延できているのか」「本当に依存パッケージを減らせているのか」あるいは「このパッケージを遅延することで起動はどれくらい速くなるのか」などを検証する道具があると便利です。<p>ファイルをロードするときには内部で<code>load-file-name</code>変数がセットされます。これを利用して、この変数に対して<code>add-variable-watcher</code>で監視を回すことで<ul><li>各パッケージのロードタイミング<li>ロードの依存関係 (誰がそのパッケージをロードしているのか)<li>おおよその所要時間</ul><p>などを解析することができます。<pre><code class="language-emacs-lisp">;; setup.el より

(defvar setup-tracker--level 0)
(defvar setup-tracker--parents nil)
(defvar setup-tracker--times nil)

(when load-file-name
  (push load-file-name setup-tracker--parents)
  (push (current-time) setup-tracker--times)
  (setq setup-tracker--level (1+ setup-tracker--level)))

(add-variable-watcher
 'load-file-name
 (lambda (_ v &amp;rest __)
   (cond ((equal v (car setup-tracker--parents))
          nil)
         ((equal v (cadr setup-tracker--parents))
          (setq setup-tracker--level (1- setup-tracker--level))
          (let* ((now (current-time))
                 (start (pop setup-tracker--times))
                 (elapsed (+ (* (- (nth 1 now) (nth 1 start)) 1000)
                             (/ (- (nth 2 now) (nth 2 start)) 1000))))
            (with-current-buffer (get-buffer-create &quot;*setup-tracker*&quot;)
              (save-excursion
                (goto-char (point-min))
                (dotimes (_ setup-tracker--level) (insert &quot;&gt; &quot;))
                (insert
                 (file-name-nondirectory (pop setup-tracker--parents))
                 &quot; (&quot; (number-to-string elapsed) &quot; msec)\n&quot;)))))
         (t
          (push v setup-tracker--parents)
          (push (current-time) setup-tracker--times)
          (setq setup-tracker--level (1+ setup-tracker--level))))))
</code></pre><p>たとえば私の Emacs でこれを使ってみると、<code>init.el</code>(<code>init.elc</code>) がロードされるまでの様子が以下のように描画されます。<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/54240/4fa39ac6-7f0c-f006-8476-5c493e93e4f3.png"alt="スクリーンショット 2020-09-12 3.08.59.png"><p><code>init.el</code>が直接ロードする Emacs Lisp ファイルは 9 個だけで、またどれも一瞬でロードが終わるものになっていることがわかります。間接的に他のパッケージを読み込むようなパッケージも含まれていません。これによって高速で起動します。<p>起動後は非同期ロードが動き始め、ロードに時間のかかるパッケージも少しづつ読まれていきます。こちらも様子を見てみると、たとえば<code>rainbow-mode.elc</code>はこのプラグインだけで<code>init.el</code>本体の 4 倍くらいロードに時間がかかっていることがわかります。これは絶対に遅延ないし非同期ロードした方がいいでしょう。<p><img src="https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/54240/2303e98a-b781-2e5c-48c1-f60664f7781c.png"alt="スクリーンショット 2020-09-12 3.14.15.png"><p>またよく見てみるとこのパッケージはさらに<code>cl-lib</code>に依存していて、ロード時間 122 msec のうち約 1/4 の 32 msec は<code>cl-lib</code>のロードに使われていることもわかります。これだけでも<code>init.el</code>本体のロードにかかる時間と同じくらいです。<code>init.el</code>から<code>cl-lib</code>依存を剥がしたい理由がわかってもらえると思います。<p>このように、実際のロードの様子や所要時間を確認しながらチューニングを進めていくことで、より確実にスピードアップを図ることができます。<h2>その他のテクニック：コンパイル時計算</h2><h3>単純なコンパイル時計算</h3><p><code>init.el</code>内に登場する純粋な (副作用のない) 計算はコンパイル時に行ってしまうことでわずかですが高速化できます。<p>たとえば重い (しかしキャッシュしても問題ない) 計算<code>omoi-keisan</code>によって定数<code>my-super-constant</code>の値が決定される場合：<pre><code class="language-emacs-lisp">(defconst my-super-constant (omoi-keisan))
</code></pre><p>これをコンパイル時計算することで起動を高速化できます。<pre><code class="language-emacs-lisp">(defconst my-super-constant
  (eval-when-compile (omoi-keisan)))
</code></pre><p>長いので適当な短い別名を割り当てておくと軽率に使えて良いと思います。起動時に計算し直す必要がないものには片っ端からつけましょう。<pre><code class="language-emacs-lisp">(defalias '! 'eval-when-compile)
(defconst my-super-constant (! (omoi-keisan)))
</code></pre><h3>コンパイル時ループアンローリング</h3><p><code>init.el</code>の中に<code>dotimes</code>,<code>dolist</code>など典型的な形のループ処理があって、かつループの範囲が静的に決まっている場合は、アンローリングしてしまった方が変数束縛などのコストがない分、効率がいいです。<pre><code class="language-diff">-(dolist (cmd '(narrow-to-region
-               dired-find-alternate-file
-               upcase-region
-               downcase-region))
-  (put cmd 'disabled nil))
+(put 'narrow-to-region 'disabled nil)
+(put 'dired-find-alternate-file 'disabled nil)
+(put 'upcase-region 'disabled nil)
+(put 'downcase-region 'disabled nil)
</code></pre><p>とはいえループの範囲が広い場合や、ループの中で行う処理が複数行にわたるような場合、やっぱり同じコードをたくさんコピペするのは気が引けます。そこで、この変換をコンパイル中にしてしまうマクロを用意しておくと便利です。変数名を指定できる必要はあまりないので、私はアナフォリックマクロ風に、<code>,it</code>で参照できるようにしています。<pre><code class="language-emacs-lisp">;; setup.el より
(defmacro !foreach (list &amp;rest body)
  &quot;Eval BODY for each elements in LIST. The current element can
be referred with `,it'.&quot;
  (declare (indent 1))
  `(progn ,@(mapcar
             (lambda (elem)
               (macroexpand-all
                (if (cadr body) `(progn ,@body) (car body))
                `((,'\, . (lambda (&amp;rest body) `',(funcall `(lambda (it) ,@body) ',elem))))))
             (eval list))))

(!foreach '(narrow-to-region
            dired-find-alternate-file
            upcase-region
            downcase-region)
  (put ,it 'disabled nil))
</code></pre><hr><p>実装が回りくどく見えますが、単純な<code>it</code>への参照だけでなく「<code>it</code>を含む式」もコンパイル時計算で展開できるようになっているためです。<pre><code class="language-emacs-lisp">(!foreach '(narrow-to-region
            dired-find-alternate-file
            upcase-region
            downcase-region)
  (message ,(symbol-name it)))
</code></pre><p><code>macroexpand-all</code>の第二引数を利用すると、このように一時的にマクロ定義を<code>flet</code>するような使い方ができてごく稀に便利です。ごく稀ですが…。<h2>その他のテクニック：環境依存バイトコンパイル</h2><p>コンパイル後のファイル<code>init.elc</code>のポータビリティを諦めれば、すなわち使うマシンごとにいちいちコンパイルすることにすれば、手間と引き換えにさらなるチューニングができるようになります。<h3>コンパイル時 load-path 解決</h3><p>通常、<code>require</code>や<code>load</code>は変数<code>load-path</code>に登録されているディレクトリを探索して目当てのパッケージを探します。しかし頻繁にパッケージの置き場を変えることがないのであれば、毎回この探索をするのは無駄です。<p>一応これらの関数はパッケージの場所をフルパスで指定することもできるのですが、とはいえベタ書きは避けたい気持ちもあります。<p>そこで、コンパイル時にそのマシンの<code>load-path</code>からパッケージを探索して、結果をキャッシュしておくようなオレオレ<code>load</code>マクロを定義しておくと便利です。<pre><code class="language-emacs-lisp">(defmacro my-load (library &amp;rest args)
  (let ((abs (locate-library library)))
    `(load ,abs ,@args)))
</code></pre><p>マシンごとにコンパイルする必要はありますが、一度コンパイルしてしまえばバイトコードにフルパスが埋め込まれるので、起動時の<code>load-path</code>の探索は不要になります。<h3>コンパイル時条件分岐</h3><p>同様にバイトコードのポータビリティを諦めることでできるもう一つの最適化は、 OS ごとの設定などの「条件分岐」のコンパイル時計算です。<p>たとえば次のように OS ごとに設定をディスパッチするようなコード片があったとき：<pre><code class="language-emacs-lisp">(if (eq system-type 'windows-nt)
    ...
  ...)
</code></pre><p>もしどうせコンパイルした時と同じマシンで使うとわかっているなら、起動時に毎回この条件のチェックを行うのは無駄です。<p>そこで、コンパイル時に中身を展開してしまうような条件分岐マクロを用意しておくと便利です。<pre><code class="language-emacs-lisp">(defmacro !if (test then &amp;rest else)
  (declare (indent 2))
  (if (eval test) then `(progn ,@else)))
</code></pre><p>私は「フォントのインストール状況によってよしなにフォントを選ぶ」設定や、「ファイルが存在する場合だけ読み込む」設定などもこれで書いています。意外と活用できるところがあると思います。<h2>その他のテクニック：ちょっとしたハックで不要な処理を省く</h2><h3>message を一時的に無効にする</h3><p>IO は重い処理なので、もしセットアップ時に重要ではないメッセージをやたら表示するパッケージがある場合は、黙らせておくことで若干起動を高速化できます。<p>以前は<code>message</code>関数を<code>flet</code>などで乗っ取る実装をしていましたが、現代の Emacs には<code>inhibit-message</code>という便利変数があるのでこれを活用します。<pre><code class="language-emacs-lisp">(let ((inhibit-message t))
  (require 'foo)
  (foo-initialize))
</code></pre><h3>Magic File Name を一時的に無効にする</h3><p>Emacs にはファイル名に応じて IO に独自の処理を挟む機構 (Magic File Name) があります。これはリモートのファイルにシームレスにアクセスするためなどに使われますが、起動処理の途中で欲しくなることはまずありません。しかし使わない場合でもファイル名のチェックは走ってしまうので、パッケージをロードする際などにはオーバーヘッドが発生します。<p>起動処理の間だけこれを無効にしておくことで、わずかに起動を速くすることができます。<p>そのためには、<code>init.el</code>の頭で<pre><code class="language-emacs-lisp">(defconst my-saved-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
</code></pre><p><code>init.el</code>のおわりで<pre><code class="language-emacs-lisp">(setq file-name-handler-alist my-saved-file-name-handler-alist)
</code></pre><p>のように設定しておけば ok です。<p>設定内容を妥協しなくても、ただ書いておくだけでちょっと速くなるのでおすすめです。<h3>GC を減らす</h3><p>Emacs Lisp ではメモリの free を人間が指示しないので、代わりにいらなくなったゴミは GC が集めます。しかし起動処理の途中でこれが走ってしまうと余計なオーバーヘッドになります。<p>そこで、起動の間だけ GC が走らないようにしておき、あとでメモリが必要になった時にまとめてお掃除してもらう方法があります。<p>Magic File Name と同様に、<code>init.el</code>の頭で<pre><code class="language-emacs-lisp">(setq gc-cons-threshold most-positive-fixnum)
</code></pre><p>などとして GC の閾値を闇雲にでかい値にしておくことで GC を実質止めることができます。<p>もちろんこのままでは無限にメモリを食いつぶしてしまい、それはそれでパフォーマンスにも悪影響なので、<code>init.el</code>のおわりでそれらしい値に戻しておく必要があります。<pre><code class="language-emacs-lisp">(setq gc-cons-threshold 16777216) ; 16mb
</code></pre><p>これもとりあえず書いておけば速くなる系なのでおすすめです。<h3>early-init.el</h3><p>Emacs 27 からは<code>init.el</code>の他に<code>early-init.el</code>というファイルも持てるようになりました。これは Emacs が起動した直後、 GUI の構築やパッケージのロードなどが行われるよりも前の、かなり初期の段階でロードされる設定ファイルです。<p>もともとパッケージシステム自体の設定などを行う用途で導入されましたが、 GUI の基本的な設定もここに入れておくと若干の効率化になります。<p>たとえばメニューバーやツールバーがいらない場合、<code>init.el</code>で次のように設定するのが一般的だと思います。<pre><code class="language-emacs-lisp">(menu-bar-mode -1)
(tool-bar-mode -1)
</code></pre><p>しかしこれでは一度バー類が構築されてからまたすぐに消すという処理になってしまうので、無駄な計算が生じます。<p><code>early-init.el</code>の中で、そもそもこれらのバー類はデフォルトで無効なものなのだと定義してしまえば：<pre><code class="language-emacs-lisp">(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
</code></pre><p>この無駄な処理を省くことができます。<p>また、もし Emacs をいつも決まったフレームサイズで起動する場合 (フルスクリーンなど)、以下の行も<code>early-init.el</code>に加えておくと<pre><code class="language-emacs-lisp">(setq frame-inhibit-implied-resize t)
</code></pre><p>フォントが読み込まれたタイミングなどでフレームサイズの再計算が入ってチカチカする現象を防げます。<h2>その他のテクニック： Emacs Lisp の細かな最適化</h2><h3>安全な関数を諦める</h3><p>Emacs の設定を書いていると、<code>add-hook</code>や<code>add-to-list</code>などの関数によく出会うと思います。これらの主な機能はリストに値を追加することですが、このときリストの要素に重複が出ないようにチェックもしてくれます。<p>一見便利なように思えますが、重複チェックはリストの全要素との比較が必要なのであまり軽い計算とはいえず、しかもあらかじめ重複しないとわかっている場合は無駄になってしまいます。<p>そこで、私は明らかに重複しないとわかっている（あるいは重複しても問題にならない）場合は<code>add-to-list</code>の代わりに<code>push</code>を使うようにしています。<pre><code class="language-emacs-lisp">(push '(&quot;\\.scad$&quot; . scad-mode) auto-mode-alist)
</code></pre><p><code>add-hook</code>には重複チェックに加えて、「リストじゃない場合はリストに変換する」などの機能も備わっているので、次のようなオレオレ雑<code>add-hook</code>を用意しておくと便利です。<pre><code class="language-emacs-lisp">(defun my-function-list-p (val)
  (or (null val) (and (consp val) (not (eq (car val) 'lambda)))))

;; 重複チェックしない add-hook
(defun my-add-global-hook (hook fn)
  (let ((oldvalue (when (default-boundp hook) (default-value hook))))
    (if (my-function-list-p oldvalue)
        (set-default hook (cons fn oldvalue))
      (set-default hook (list fn oldvalue)))))
</code></pre><h3>defsubst</h3><p>Emacs Lisp にも関数のインライン展開があります。<p><code>defun</code>と同じ要領で<code>defsubst</code>を使って定義でき、コンパイラーに対してインライン化してもいいよという指示を出せます。小さな関数に適用していくことで、関数呼び出し分のコストを削減することができます。<h3>lexical-binding</h3><p>Emacs Lisp は現時点ではデフォルトで動的束縛です。<pre><code class="language-emacs-lisp">(defvar fn
  (let ((a 1))
    (lambda (x) (+ x a))))

;; 関数定義時には a が定義されていたが、今はされていない
(funcall fn 3) ;; =&gt; void variable 'a'

;; a が定義されている環境で呼び出すとそれが参照される
(let ((a 2))
  (funcall fn 3)) ;; =&gt; 5
</code></pre><p>が、最近はローカル変数をまとめて静的束縛にすることができる<code>lexical-binding</code>オプションが実装されているので、静的束縛を利用することもできます。<pre><code class="language-emacs-lisp">;;; -*- lexical-binding: t -*-

(defvar fn
  (let ((a 1))
    (lambda (x) (+ x a))))

;; 関数定義時の a の値を関数が覚えている (関数閉包)
(funcall fn 3) ;; =&gt; 4

;; 新しいスコープで a をシャドーイングしても関数の振る舞いは変わらない
(let ((a 2))
  (funcall fn 3)) ;; =&gt; 4
</code></pre><p>変数が静的に束縛されるとわかっていると、たとえば<a href="https://emacs.stackexchange.com/questions/2129/why-is-let-faster-with-lexical-scope"><code>let</code>がただの stack push / pop で済むなど</a>、最適化の余地が広がるので効率よく実行できます。<p>動的束縛でないと困るという場面はさほど多くないので、「俺、いま動的束縛活用してんなー」という自覚なしに書いている<code>init.el</code>はおそらく<code>lexical-binding: t</code>にしても問題なく動くと思います (動かない場合、たいてい警告が出るので従いましょう)。<hr><p>自分はずっと、動的束縛こそ Emacs Lisp の味だぜと思って<code>lexical-binding</code>を使ってこなかったのですが、静的束縛になるのは変数束縛だけだと知って宗旨替えしました。<p>advice や関数再定義こそ Emacs Lisp の真髄だなあと思うことがあります。<h3>オブジェクトの実体を意識する</h3><p>Emacs Lisp には似たような機能の関数が複数あることがあります。それぞれの実装を理解して使い分けることで、より効率の良い設定ファイルを書くことができます。<h4>等値比較</h4><p><code>eq</code>,<code>eql</code>,<code>equal</code>はどれも等値比較の関数ですが、<ul><li><code>eq</code>... オブジェクトの実体が同じ<li><code>eql</code>... オブジェクトの実体が同じか、数値として等しい<li><code>equal</code>... オブジェクトの実体が同じか、数値として等しいか、文字列として等しいか、リストや配列の要素がすべて等しい</ul><p>のように判定の緩さと実行効率に違いがあります。特に<code>equal</code>については、コレクションの全ての要素を確認するので他の比較に比べて顕著に遅いです。判定の目的に応じて適切に使い分けましょう。<p>比較の対象が数値や文字列とあらかじめわかっている場合は、<code>=</code>,<code>string=</code>などの専用の関数もあります。<p>要素が配列に含まれているかを検査する関数など、内部的に等値比較をおこなう関数群にも同様に<code>memq</code>,<code>memql</code>,<code>member</code>などのバリエーションがあるので、使い分けましょう。<h4>コンスセルを理解する</h4><p>LISP のリストは、空リスト (<code>nil</code>) に「コンスセル」（２要素タプル）を被せていくことで作られます：<pre><code class="language-emacs-lisp">(cons 1 (cons 2 (cons 3 nil))) ;; = '(1 2 3)
</code></pre><p>要はリンクトリストです。<p>たとえば二つのリストを連結したいとき、 Emacs Lisp では<code>append</code>または<code>nconc</code>を使うことができますが、それぞれ次のような違いがあります。<ul><li><code>(append A B)</code>...<code>A</code>,<code>B</code>の要素をすべて並べた新しいリストを作る<li><code>(nconc A B)</code>... リスト<code>A</code>の末尾を<code>nil</code>からリスト<code>B</code>に置き換える</ul><p>後者は新しいコンスセルをアロケートしないので効率が良いです。<p>ただし、元のリスト<code>A</code>は破壊されてしまいます。また<code>B</code>も破壊こそされませんが、一方でコピーもされません。たとえば以下のようなコードを実行すると：<pre><code class="language-emacs-lisp">(defconst a '(1 2 3))
(defconst b (nconc '(1 2 3) a)) ;; =&gt; '(1 2 3 1 2 3)
(defconst c (nconc '(3 2 1) a)) ;; =&gt; '(3 2 1 1 2 3)
</code></pre><p>メモリ上には木構造のようなものができあがります。<pre><code class="language-text">(b) 1 - 2 - 3
             \
              +- (a) 1 - 2 - 3
             /
(c) 3 - 2 - 1
</code></pre><p>ここでたとえばリスト<code>a</code>の先頭<code>1</code>を破壊的に書き換えると：<pre><code class="language-emacs-lisp">(setcar a 9)
(print a) ;; =&gt; '(9 2 3)
</code></pre><p>残りのリストたちも書き換わります。<pre><code class="language-emacs-lisp">(print b) ;; =&gt; '(1 2 3 9 2 3)
(print c) ;; =&gt; '(3 2 1 9 2 3)
</code></pre><pre><code class="language-text">(b) 1 - 2 - 3
             \
              +- (a) 9 - 2 - 3
             /
(c) 3 - 2 - 1
</code></pre><p>コンスセルやリストはいたるところで使う LISP の基本オブジェクトなので、このような仕組みを理解した上で上手に活用していくと、よりパフォーマンスの出る Emacs Lisp を書くことができます。<h2>おまけ：飛び道具たち</h2><p>本文では紹介しなかった離れ技たちのアイデアだけ、最後に紹介しておきます。<p>難しいしちゃんと動く保証もないのでオススメはしません。<h3>コンパイル時パッケージ読み込み</h3><p>「起動時に必須なパッケージ」をせめて効率よくロードするために試したテクニックです。<p>ロード対象のパッケージのコードをコンパイル中に読み込んでしまって、コンパイル結果の<code>init.elc</code>に直接埋め込んでしまいます。<p>これによりファイルを開きにいくコストが削減できると思いました。<p>効果はわりとシステムによってまちまちのようで、 Windows ではかなり効果がでたものの、他はイマイチでした。 Windows 機を使うことが減ったのと、いかんせんかなりワイルドなテクニックで動作も不安定なところがあったので使うのはやめました。<p>一応<code>setup.el</code>に名残のコードがあるので、興味のある方は読んだり使ったりしてみてください。自前で<code>load-history</code>をメンテしたり、なかなか過激なコードになっているので面白いとは思います。<h3>ポータブルダンパー</h3><p>Emacs 27 から unexec に代わって使われるようになった pdump を悪用するアイデアです。<p>「起動時に必須なパッケージ」のロードが終わった状態の Emacs を作って、それを pdump します。<p>そもそも「カスタマイズ後の Emacs を正しく pdump することは目標としていない」と明言されているので、かなり工夫して使う必要はありそうですが、もしうまくいけば相当な効率化が期待できます。<p>やってみたいなとは思いつつまだできていません。<h2>まとめ</h2><p>Emacs の起動時間を詰めるために使える小技や大技たちを紹介しました。<p>なにか他にも面白いテクニックや話題を知っている方は、ぜひコメントや記事を書いて教えてもらえると嬉しいです。<p>よき Emacs ライフを！</div></div><hr><p><a class="link"href="javascript:history.back()">&lt; 戻る</a></div><script>const lazyScripts=["/js/prefetch.js","/js/stalker.js","/js/activity.js"],lazyStyles=["/css/common.css","/css/stalker.css"]</script>